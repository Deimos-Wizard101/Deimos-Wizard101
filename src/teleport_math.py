import asyncio
from wizwalker import XYZ, Orient, Client, Keycode
from wizwalker.file_readers.wad import Wad
import math
import struct
from io import BytesIO
from typing import Tuple, Union
from src.utils import is_free, get_quest_name, is_visible_by_path, get_popup_title
from src.paths import npc_range_path
from enum import auto, IntEnum

type_format_dict = {
"char": "<c",
"signed char": "<b",
"unsigned char": "<B",
"bool": "?",
"short": "<h",
"unsigned short": "<H",
"int": "<i",
"unsigned int": "<I",
"long": "<l",
"unsigned long": "<L",
"long long": "<q",
"unsigned long long": "<Q",
"float": "<f",
"double": "<d",
}



class TypedBytes(BytesIO):
    def split(self, index: int) -> Tuple["TypedBytes", "TypedBytes"]:
        self.seek(0)
        buffer = self.read(index)
        return type(self)(buffer), type(self)(self.read())
    def read_typed(self, type_name: str):
        type_format = type_format_dict[type_name]
        size = struct.calcsize(type_format)
        data = self.read(size)
        return struct.unpack(type_format, data)[0]



# implemented from https://github.com/PeechezNCreem/navwiz/
# this licence covers the below function
# Boost Software License - Version 1.0 - August 17th, 2003
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

def parse_nav_data(file_data: Union[bytes, TypedBytes]):
    # ty starrfox for remaking this
    if isinstance(file_data, bytes):
        file_data = TypedBytes(file_data)
    vertex_count = file_data.read_typed("short")
    vertex_max = file_data.read_typed("short")
    # unknown bytes
    file_data.read_typed("short")
    vertices = []
    idx = 0
    while idx <= vertex_max - 1:
        x = file_data.read_typed("float")
        y = file_data.read_typed("float")
        z = file_data.read_typed("float")
        vertices.append(XYZ(x, y, z))
        vertex_index = file_data.read_typed("short")
        if vertex_index != idx:
            vertices.pop()
            vertex_max -= 1
        else:
            idx += 1
    edge_count = file_data.read_typed("int")
    edges = []
    for idx in range(edge_count):
        start = file_data.read_typed("short")
        stop = file_data.read_typed("short")
        edges.append((start, stop))
    return vertices, edges

def get_neighbors(vertex: XYZ, vertices: list[XYZ], edges: list[(int, int)]):
    vert_idx = -1
    for v in vertices:
        vert_idx += 1
        if v == vertex:
            break
    if vert_idx == -1:
        # no matching index found, return empty
        return []

    result = []
    for edge in edges:
        if edge[0] == vert_idx:
            result.append(vertices[edge[1]])
    return result


def calc_PointOn3DLine(xyz_1 : XYZ, xyz_2 : XYZ, additional_distance):
    # extends a point on the line created by 2 XYZs by additional_distance. xyz_1 is the origin.
    distance = calc_Distance(xyz_1, xyz_2)
    # distance = math.sqrt((pow(xyz_1.x - xyz_2.x, 2.0)) + (pow(xyz_1.y - xyz_2.y, 2.0)) + (pow(xyz_1.z - xyz_2.z, 2.0)))
    # Doing a rough distance check here since XYZ's aren't always equal even if they have seemingly the same values
    if distance < 1.0:
        return xyz_1
    else:
        n = ((distance - additional_distance) / distance)
        return XYZ(x=((xyz_2.x - xyz_1.x) * n) + xyz_1.x, y=((xyz_2.y - xyz_1.y) * n) + xyz_1.y, z=((xyz_2.z - xyz_1.z) * n) + xyz_1.z)


def calc_multiplerPointOn3DLine(xyz_1 : XYZ, xyz_2 : XYZ, multiplier : float):
    # extends a point on the line created by 2 XYZs by a multiplier. xyz_1 is the origin.
    return XYZ(x=((xyz_2.x - xyz_1.x) * multiplier) + xyz_1.x, y=((xyz_2.y - xyz_1.y) * multiplier) + xyz_1.y, z=((xyz_2.z - xyz_1.z) * multiplier) + xyz_1.z)


def rotate_point(origin_xyz : XYZ, point_xyz : XYZ, theta):
    # rotates point_xyz about origin_xyz, by theta degrees counterclockwise. This doesn't take the Z into account, so don't use this for anything that needs the Z to rotate.
    radians = math.radians(theta)
    cos = math.cos(radians)
    sin = math.sin(radians)
    y_diff = point_xyz.y - origin_xyz.y
    x_diff = point_xyz.x - origin_xyz.x
    x = cos * x_diff - sin * y_diff + origin_xyz.x
    y = sin * x_diff + cos * y_diff + origin_xyz.y
    return XYZ(x=x, y=y, z=point_xyz.z)


def are_xyzs_within_threshold(xyz_1 : XYZ, xyz_2 : XYZ, threshold : int = 200):
    # checks if 2 xyz's are within a rough distance threshold of each other. Not actual distance checking, but precision isn't needed for this, this exists to eliminate tiny variations in XYZ when being sent back from a failed port.
    threshold_check = [abs(abs(xyz_1.x) - abs(xyz_2.x)) < threshold, abs(abs(xyz_1.y) - abs(xyz_2.y)) < threshold, abs(abs(xyz_1.z) - abs(xyz_2.z)) < threshold]
    return all(threshold_check)


def calc_squareDistance(xyz_1 : XYZ, xyz_2 : XYZ):
    # calculates the distance between 2 XYZs, but doesn't square root the answer to be much more efficient. Useful for comparing distances, not much else.
    return (pow(xyz_1.x - xyz_2.x, 2.0)) + (pow(xyz_1.y - xyz_2.y, 2.0)) + (pow(xyz_1.z - xyz_2.z, 2.0))


def calc_Distance(xyz_1 : XYZ, xyz_2 : XYZ):
    # calculates the distance between 2 XYZs
    return math.sqrt(calc_squareDistance(xyz_1, xyz_2))


async def calc_FrontalVector(client: Client, xyz : XYZ = None, yaw : float = None, speed_constant : int = 580, speed_adjusted : bool = True, length_adjusted : bool = True):
    # handle if it is adjusted via speed multiplier or just uses the set constant
    if speed_adjusted:
        current_speed = await client.client_object.speed_multiplier()
    else:
        current_speed = 0

    # handles optional xyz param, will default to using the position of the client
    if not xyz:
        xyz = await client.body.position()

    # handles optional yaw paraam, will default to using the yaw of the client
    if not yaw:
        yaw = await client.body.yaw()
    else:
        yaw = yaw

    # adjust the speed constant based on the speed multiplier
    additional_distance = speed_constant * ((current_speed / 100) + 1)

    # calculate point "in front" of XYZ/client using yaw
    frontal_x = (xyz.x - (additional_distance * math.sin(yaw)))
    frontal_y = (xyz.y - (additional_distance * math.cos(yaw)))
    frontal_xyz = XYZ(x=frontal_x, y=frontal_y, z=xyz.z)

    # make a length adjustment since diagonal movements
    if length_adjusted:
        distance = calc_Distance(xyz, frontal_xyz)
        final_xyz = calc_PointOn3DLine(xyz_1=xyz, xyz_2=frontal_xyz, additional_distance=(additional_distance - distance))
    else:
        final_xyz = frontal_xyz

    return final_xyz


# TODO: This has 2 duplicates
async def load_wad(path: str):
    if path is not None:
        return Wad.from_game_data(path.replace("/", "-"))


async def fallback_spiral_tp(client: Client, xyz: XYZ):
    raise NotImplementedError()

async def navmap_tp(client: Client, xyz: XYZ = None, leader_client: Client = None):
    # TODO: What is leader_client meant to be for?
    if not await is_free(client):
        return

    starting_zone = await client.zone_name() # for loading the correct wad and to walk to target as a last resort
    starting_xyz = await client.body.position()
    target_xyz = xyz if xyz is not None else await client.quest_position.position()

    def check_sigma(a: XYZ, b: XYZ, sigma=20.0):
        # check if a distance is more or less zero
        return calc_Distance(a, b) <= sigma

    async def check_success():
        # Check if the teleport succeeded. For this we want to have moved away from the starting position.
        await asyncio.sleep(0.1) # make sure we got useful information
        return not check_sigma(await client.body.position(), starting_xyz)

    async def finished_tp():
        return check_success() or not await is_free(client) or await client.zone_name() != starting_zone

    if check_sigma(starting_xyz, target_xyz):
        return # save some work

    await client.teleport(target_xyz)
    if await finished_tp():
        return # trivial tp, no point using a more complex method if this one works

    try:
        # attempt to use the nav data
        wad = await load_wad(starting_zone)
        nav_file = await wad.get_file("zone.nav")
        vertices, edges = parse_nav_data(nav_file)
    except:
        # Unable to load nav data. Fall back to primitive spiral pattern
        await fallback_spiral_tp(client, target_xyz)
        return

    # continuation of nav data tp, don't want to swallow potential exceptions in this section
    closest_vertex = vertices[0]
    lowest_distance = calc_Distance(closest_vertex, target_xyz)
    for vertex in range(1, len(vertices)):
        vert_dist = calc_Distance(vertex, target_xyz)
        if vert_dist < lowest_distance:
            closest_vertex = vertex
            lowest_distance = vert_dist

    await client.teleport(closest_vertex)
    if await check_success():
        # second trivial case, the closest vertex worked.
        if await is_free(client) and await client.zone_name() == starting_zone:
            # make sure we get all the way there
            await client.goto(target_xyz.x, target_xyz.y)
        return

    # breadth first search until a vertex works, build path on the way so we can walk in case we are far away
    max_search_dist = 1000.0
    queue = [[closest_vertex]]
    found_path = None
    visited = set()
    while len(queue) > 0:
        path = queue.pop(0)
        v = path[-1]
        visited.add(v)
        await client.teleport(v)
        if await finished_tp():
            found_path = path
            break
        for neighbor in get_neighbors(v, vertices, edges):
            if neighbor in visited or not check_sigma(neighbor, target_xyz, sigma=max_search_dist):
                continue
            new_path = list(path)
            new_path.append(neighbor)
            queue.append(new_path)

    if found_path == None:
        # no viable navmap-based path found, use spiral
        await fallback_spiral_tp(client, target_xyz)
        return

    # Walk the created path in case we are far away
    if found_path != None and await client.zone_name() == starting_zone and not check_sigma(found_path[-1], target_xyz):
        for v in reversed(found_path):
            await client.goto(v.x, v.y)


def calc_chunks(points: list[XYZ], origin: XYZ = XYZ(x=0.0, y=0.0, z=0.0), entity_distance: float = 3147.0) -> list[XYZ]:
    # Returns a list of center points of "chunks" of the map, as defined by the input points.
    x1 = origin
    y1 = origin
    x2 = origin
    y2 = origin

    for xyz in points:
        if xyz.x < x1.x:
            x1 = xyz
        if xyz.y < y1.y:
            y1 = xyz
        if xyz.x > x2.x:
            x2 = xyz
        if xyz.y > y2.y:
            y2 = xyz

    least_point = XYZ(x1.x, y1.y, origin.z)
    most_point = XYZ(x2.x, y2.y, origin.z)

    max_radius = max([calc_Distance(origin, least_point), calc_Distance(origin, most_point)])
    max_radius -= entity_distance

    entity_diameter = entity_distance * 2

    current_radius = entity_diameter

    chunk_points = [origin]

    iterations = math.ceil(max_radius / current_radius)
    print(f'Iterations: {iterations}')
    for _ in range(iterations):
        circumference = (2.0 * math.pi) * current_radius
        sides = math.ceil(circumference / entity_diameter)
        print(f'Sides: {sides}')
        angle_increment = 360 / sides

        frontal_y = origin.y - current_radius
        frontal_xyz = XYZ(origin.x, frontal_y, origin.z)

        for s in range(sides):
            if s != 0:
                angle = angle_increment * s
                rotated_pos = rotate_point(origin, frontal_xyz, angle)
                if calc_squareDistance(rotated_pos, origin) <= calc_squareDistance(most_point, origin):
                    chunk_points.append(rotated_pos)

        current_radius += entity_diameter

    print(f'chunks:{len(chunk_points)}')
    return chunk_points


def calculate_yaw(xyz_1: XYZ, xyz_2: XYZ) -> float:
    # Calculates the yaw between 2 points.
    dx = xyz_1.x - xyz_2.x
    dy = xyz_1.y - xyz_2.y

    return math.atan2(dx, dy)


def calculate_pitch(xyz_1: XYZ, xyz_2: XYZ) -> float:
    # Find the reference vector
    x = xyz_2.x - xyz_1.x
    y = xyz_2.y - xyz_1.y
    z = xyz_2.z - xyz_1.z

    return -math.atan2(z, math.sqrt(x ** 2 + y ** 2))
